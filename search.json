[{"path":"https://bayesiandemography.github.io/command/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Bayesian Demography Limited Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Start Guide","text":"article shows get started package command. main function command cmd_assign(), assigns objects global environment. cmd_assign() can called two ways: Interatively Inside script run command line Case 2 important one. Case 1 simpler, however, look first.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"calling-cmd_assign-interactively","dir":"Articles","previous_headings":"","what":"Calling cmd_assign() interactively","title":"Quick Start Guide","text":"Running effect running snippets add two objects global environment names \"obj1\" \"obj2\" values \"orange\" 1. Objects assigned cmd_assign() can following classes: character, eg \"Hello world\" integer, eg 3L numeric, eg 3.141593 date, eg .Date(\"2015-11-03\") date-time using POSIXct, eg .POSIXct(\"2015-11-03 14:23:03\") date-time using POSIXlt, eg .POSIXlt(\"2015-11-03 14:23:03\") NULL objects must length 1, except NULL, length 0. typical reason using cmd_assign() interactively develop code eventually sit script run command line. common way run R scripts command line Rscript, take detour look .","code":"cmd_assign(obj1 = \"a\",            obj2 = 1\")) obj1 <- \"orange\" obj2 <- 1"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"rscript","dir":"Articles","previous_headings":"","what":"Rscript","title":"Quick Start Guide","text":"Rscript application running R scripts command line. introduction command line, see episodes 1–3 Unix Shell. introduction Rscript, see Command-Line Programs. simplest usage command like launches new R session, runs whatever code myfile.R, ends session. session ends, objects disappear, unless saved disk. Rscript accepts additional arguments, placed path file run, example, --n_iteration=10 named argument, output.rds unnamed argument. Named arguments format Note must space name, = sign, value, invalid: Named arguments can also single dash single letter, Rscript called additional arguments, Rscript supplies names values arguments R session. names values can accessed within session using base R function commandArgs(). Working commandArgs() , however, tricky. cmd_assign() alternative commandArgs(), designed specifically workflows data analysis. One alternative running R scripts command line package littler. littler run Windows, requires fiddling symbolic links runs macOS. cmd_assign() works normal littler.","code":"Rscript myfile.R Rscript myfile.R --n_iteration=10 output.rds --<name>=<value> Rscript myfile.R --n_iteration = 10 output.rds   # invalid! Rscript myfile.R -n=10"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"calling-cmd_assign-inside-a-script","dir":"Articles","previous_headings":"","what":"Calling cmd_assign() inside a script","title":"Quick Start Guide","text":"work example call cmd_assign() inside script run command line. current working directory contains two files: file airmiles.csv holds data annual passenger numbers: file fig_smoothed.R contains following code: code reads data file whose name specified .airmiles, smooths passenger data, amount smoothing controlled n_knot, plots smoothed unsmoothed values, writes plot file whose name specified .. use Rscript run code command line. Rscript started new R session, ran code using command line arguments passed , ended session. call cmd_assign() fig_smoothed.R created objects .airmiles, n_knot, .inside R session. values objects taken command line, original call cmd_assign(). Hence, n_knot equaled 8 rather 10, .equaled \"fig_smoothed_8.png\" rather \"fig_smoothed.png\". working directory now looks like : new file called \"fig_smoothed_8.png\".","code":". ├── airmiles.csv ├── fig_smoothed.R └── report.qmd year,passengers 1937,412 1938,480 1939,683 1940,1052 1941,1385 1942,1418 1943,1634 1944,2178 1945,3362 1946,5948 1947,6109 1948,5981 1949,6753 1950,8003 ## Specify packages, inputs, and outputs ------------------  suppressPackageStartupMessages({   library(dplyr)   library(ggplot2)   library(command) })  cmd_assign(.airmiles = \"data/airmiles.csv\",            n_knot = 10,            .out = \"fig_smoothed.png\")   ## Read in data -------------------------------------------  airmiles <- read.csv(.airmiles)   ## Analyse ------------------------------------------------  smoothed <- airmiles |>   mutate(smoothed = fitted(smooth.spline(x = passengers,                                          nknots = n_knot)))  p <- ggplot(smoothed, aes(x = year)) +   geom_line(aes(y = smoothed)) +   geom_point(aes(y = passengers)) +   ggtitle(paste(\"Smoothed using\", n_knot, \"knots\"))   ## Save results -------------------------------------------  png(file = .out, width = 200, height = 200) plot(p) dev.off() Rscript fig_smoothed.R airmiles.csv 8 fig_smoothed_8.png ✔ Assigned object `.airmiles` with value \"airmiles.csv\" and class \"character\". ✔ Assigned object `n_knot` with value 8 and class \"numeric\". ✔ Assigned object `.out` with value \"fig_smoothed_8.png\" and class \"character\". null device            1 . ├── airmiles.csv ├── fig_smoothed.R ├── fig_smoothed_8.png └── report.qmd"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"what-cmd_assign-does-when-called-in-a-script","dir":"Articles","previous_headings":"","what":"What cmd_assign() does when called in a script","title":"Quick Start Guide","text":"cmd_assign() called script run command line, three things: Match command line arguments arguments cmd_assign(). Coerce value supplied command line class corresponding value call cmd_assign(). Assign resulting values global environment. Say, instance, script called model.R containing following call cmd_assign(). run model.R command line using first called, cmd_assign() holds following values: match step, `cmd_assign() finds values passed command line. First matches named arguments command line named arguments call, yielding matches unnamed arguments command line unused arguments call. matching unnamed arguments based order unnamed arguments supplied command line. example, value \"data/dataset2.csv\" passed \"/model2.rds\", \"data/dataset2.csv\" comes \"/model2.rds\" matched results. values supplied command line start text strings. coerce step, cmd_assign() converts values classs matched values cmd_assign(). example, means coercing \"10\" numeric coercing \"TRUE\" logical. Finally, assign step, cmd_assign() puts values global environment. number arguments passed command line must exactly match number arguments specified call cmd_assign(). Values specified call cmd_assign() act defaults. instance, example, cmd_assign() let us omit use_log, following invalid:","code":"cmd_assign(.data = \"data/dataset.csv\",            n_iter = 5,            use_log = TRUE,            .out = \"out/model.rds\") Rscript model.R data/dataset2.csv out/model2.rds --use_log=TRUE --n_iter=10 Rscript model.R data/dataset2.csv out/model2.rds --n_iter=10  # invalid!"},{"path":[]},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"argument-names-starting-with-a-dot","dir":"Articles","previous_headings":"Naming conventions","what":"Argument names starting with a dot","title":"Quick Start Guide","text":"examples far, objects holding paths filenames conformed particular naming convention convention: objects names start dot. instance: idea behind convention distinguish values references. n_iter use_log example hold values directly used analysis. .data ., contrast, describe values stored. distinction analogous one ordinary variables pointers C. access values referred “dot” variables, use function readRDS() read_csv(), dot-name convention compulsory, cmd_assign() check . convention nevertheless worth following, can easy practice get confused value reference value.","code":"cmd_assign(.data = \"data/dataset.csv\", # '.data' starts with a dot            n_iter = 5,            use_log = TRUE,            .out = \"out/model.rds\")     # '.out' starts with a dot data <- read_csv(.data)"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"giving-code-files-and-outputs-the-same-base-name","dir":"Articles","previous_headings":"Naming conventions","what":"Giving code files and outputs the same base name","title":"Quick Start Guide","text":"Another feature examples far files R code base name files generated output. File fig_smoothed.R, instance, generated fig_smooth.png, fig_smooth_5.png, fig_smooth_8.png, fig_smooth_10.png, file model.R generated model.rds model2.rds. rely file extensions (eg .R vs .png) distinguish code outputs, use suffixes (eg _5, _8 _10) distinguish different versions output. Naming conventions like common system programming, good way signal relationship code outputs.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"putting-calls-to-rscript-in-a-shell-script","dir":"Articles","previous_headings":"","what":"Putting calls to Rscript in a shell script","title":"Quick Start Guide","text":"can create data analysis workflow writing shell script calls Rscript. illustrate simple example. need two new files. first file, called report.qmd, creates report two figures. contains following code. second file, called workflow.sh, shell script runs whole workflow. contains following code: third command workflow.sh calls quarto application directly, rather R function quarto_render. run workflow.sh. working directory now contains two graphs report (plus directory, called report_files, created quarto.)","code":"--- title: \"Smoothed Passenger Miles\" format: html ---  We smoothing our data using a spline with 5 knots:  ```{r} #| label: fig_smoothed_5 #| echo: false knitr::include_graphics(\"fig_smoothed_5.png\") ```  And smooth it again using a spline with 10 knots  ```{r} #| label: fig_smoothed_10 #| echo: false knitr::include_graphics(\"fig_smoothed_10.png\") ``` Rscript fig_smoothed.R airmiles.csv 5 fig_smoothed_5.png   Rscript fig_smoothed.R airmiles.csv 10 fig_smoothed_10.png   quarto render report.qmd bash workflow.sh ✔ Assigned object `.airmiles` with value \"airmiles.csv\" and class \"character\". ✔ Assigned object `n_knot` with value 5 and class \"numeric\". ✔ Assigned object `.out` with value \"fig_smoothed_5.png\" and class \"character\". null device            1  ✔ Assigned object `.airmiles` with value \"airmiles.csv\" and class \"character\". ✔ Assigned object `n_knot` with value 10 and class \"numeric\". ✔ Assigned object `.out` with value \"fig_smoothed_10.png\" and class \"character\". null device            1    processing file: report.qmd 1/5                   2/5 [fig_smoothed_5]  3/5                   4/5 [fig_smoothed_10] 5/5                   output file: report.knit.md  pandoc    to: html   output-file: report.html   standalone: true   section-divs: true   html-math-method: mathjax   wrap: none   default-image-extension: png   variables: {}    metadata   document-css: false   link-citations: true   date-format: long   lang: en   title: Smoothed Passenger Miles    Output created: report.html . ├── airmiles.csv ├── fig_smoothed.R ├── fig_smoothed_10.png ├── fig_smoothed_5.png ├── fig_smoothed_8.png ├── report.html ├── report.qmd ├── report_files └── workflow.sh"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"putting-calls-to-rscript-in-a-makefile","dir":"Articles","previous_headings":"","what":"Putting calls to Rscript in a Makefile","title":"Quick Start Guide","text":"even better way organize data analysis workflow put Rscript commands Makefile. introduction Makefiles, see Project Management Make. Makefile equivalent workflow.sh file: delete fig_smoothed_5.png run Makefile. Whereas bash script workflow.sh recreated fig_smoothed_5.png, fig_smoothed_10.png report.html, Make recognises fig_smoothed_10.png still --date, recreates fig_smoothed_5.png report.html. Makefiles take time master, important advantages, discussed Modular Workflows Data Analysis.","code":".PHONY: all all: report.pdf  fig_smoothed_5.png: fig_smoothed.R airmiles.csv     Rscript $^ $@ --n_knot=5    fig_smoothed_10.png: fig_smoothed.R airmiles.csv     Rscript $^ $@ --n_knot=10  report.pdf: report.qmd fig_smoothed_5.png fig_smoothed_10.png     quarto render $< rm fig_smoothed_5.png make Rscript fig_smoothed.R airmiles.csv fig_smoothed_5.png --n_knot=5   ✔ Assigned object `.airmiles` with value \"airmiles.csv\" and class \"character\". ✔ Assigned object `n_knot` with value 5 and class \"numeric\". ✔ Assigned object `.out` with value \"fig_smoothed_5.png\" and class \"character\". null device            1  quarto render report.qmd   processing file: report.qmd 1/5                   2/5 [fig_smoothed_5]  3/5                   4/5 [fig_smoothed_10] 5/5                   output file: report.knit.md  pandoc    to: html   output-file: report.html   standalone: true   section-divs: true   html-math-method: mathjax   wrap: none   default-image-extension: png   variables: {}    metadata   document-css: false   link-citations: true   date-format: long   lang: en   title: Smoothed Passenger Miles    Output created: report.html"},{"path":"https://bayesiandemography.github.io/command/articles/a1_quickstart.html","id":"sec:alt","dir":"Articles","previous_headings":"","what":"Alternatives to cmd_assign()","title":"Quick Start Guide","text":"cmd_assign() option processing command line arguments. One alternative cmdArgs() package R.utils, user-friendly version base R function commandArgs(). Another package docopt, can used construct interface script, including processing command line arguments. cmd_assign() specialised cmdArgs() docopt. focuses specifically task processing command line arguments part data analysis workflow.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating a Shell Script","text":"Functions extract_shell() shell_script() help writing shell script control data analysis workflow. extract_shell() shell_script() work, additional editing usually necessary.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"an-example-workflow","dir":"Articles","previous_headings":"","what":"An example workflow","title":"Creating a Shell Script","text":"demonstrate, use simple workflow code, aside shell script, already written. project directory contains following files: workflow five steps: src/cleaned_data.R reads raw data, cleans , creates /cleaned_data.rds src/model.R fits model cleaned data, creates /model.rds src/vals_fitted.R extract fitted values model, creates vals_fitted.rds src/fig_fitted.R uses vals_fitted.rds create plot /fig_fitted.png report.qmd uses /fig_fitted.png create document report.html cleaned_data.R, model.R, vals_fitted.R, fig_fitted.R contain calls cmd_assign(). instance, src/model.R contains lines","code":". ├── data │   └── raw_data.csv ├── out ├── report.qmd └── src     ├── cleaned_data.R     ├── fig_fitted.R     ├── model.R     └── vals_fitted.R cmd_assign(.cleaned_data = \"out/cleaned_data.rds\",            .out = \"out/model.rds\")"},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"extract_shell","dir":"Articles","previous_headings":"","what":"extract_shell()","title":"Creating a Shell Script","text":"extract_shell() extracts call cmd_assign() R file, turns shell command. instance, call return value easiest way use extract_shell() call R console, cut--paste results shell script.","code":"extract_shell(\"src/model.R\") Rscript /home/runner/work/command/command/vignettes/articles/src/model.R \\   out/cleaned_data.rds \\   out/model.rds"},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"shell_script","dir":"Articles","previous_headings":"","what":"shell_script()","title":"Creating a Shell Script","text":"shell_script() creates draft whole shell script. shell_script() loops R files directory, extracting cmd_assign() calls converting shell commands. puts shell commands script. instance, call creates new file called workflow.sh lines , cases, output shell_script() needs editing ready use. ordering commands workflow.sh reflects ordering files src directory. need rearrange commands instead reflect order need executed. also add instructions rendering file report.qmd.","code":"shell_script(\"src\") Rscript src/cleaned_data.R \\   data/raw_data.csv \\   out/cleaned_data.rds  Rscript src/fig_fitted.R \\   out/vals_fitted.rds \\   out/fig_fitted.png  Rscript src/model.R \\   out/cleaned_data.rds \\   out/model.rds  Rscript src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model.rds \\   out/vals_fitted.rds Rscript src/cleaned_data.R \\   data/raw_data.csv \\   out/cleaned_data.rds  Rscript src/model.R \\   out/cleaned_data.rds \\   out/model.rds  Rscript src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model.rds \\   out/vals_fitted.rds  Rscript src/fig_fitted.R \\   out/vals_fitted.rds \\   out/fig_fitted.png  quarto render report.qmd"},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"running-the-shell-script","dir":"Articles","previous_headings":"","what":"Running the shell script","title":"Creating a Shell Script","text":"project directory looks like . run shell script. project directory now looks like . created cleaned_data.rds, model.rds, vals_fitted.rds, fig_fitted.png directory, report.html main directory. report_files directory created quarto.","code":". ├── data │   └── raw_data.csv ├── out ├── report.qmd ├── src │   ├── cleaned_data.R │   ├── fig_fitted.R │   ├── model.R │   └── vals_fitted.R └── workflow.sh bash workflow.sh ✔ Assigned object `.raw_data` with value \"data/raw_data.csv\" and class \"character\". ✔ Assigned object `.out` with value \"out/cleaned_data.rds\" and class \"character\". ✔ Assigned object `.cleaned_data` with value \"out/cleaned_data.rds\" and class \"character\". ✔ Assigned object `.out` with value \"out/model.rds\" and class \"character\". ✔ Assigned object `.cleaned_data` with value \"out/cleaned_data.rds\" and class \"character\". ✔ Assigned object `.model` with value \"out/model.rds\" and class \"character\". ✔ Assigned object `.out` with value \"out/vals_fitted.rds\" and class \"character\". ✔ Assigned object `.vals_fitted` with value \"out/vals_fitted.rds\" and class \"character\". ✔ Assigned object `.out` with value \"out/fig_fitted.png\" and class \"character\". null device            1    processing file: report.qmd 1/3                   2/3 [unnamed-chunk-1] 3/3                   output file: report.knit.md  pandoc    to: html   output-file: report.html   standalone: true   section-divs: true   html-math-method: mathjax   wrap: none   default-image-extension: png   variables: {}    metadata   document-css: false   link-citations: true   date-format: long   lang: en   title: Swiss Fertility    Output created: report.html . ├── data │   └── raw_data.csv ├── out │   ├── cleaned_data.rds │   ├── fig_fitted.png │   ├── model.rds │   └── vals_fitted.rds ├── report.html ├── report.qmd ├── report_files │   └── libs ├── src │   ├── cleaned_data.R │   ├── fig_fitted.R │   ├── model.R │   └── vals_fitted.R └── workflow.sh"},{"path":"https://bayesiandemography.github.io/command/articles/a2_shell_script.html","id":"other-resources","dir":"Articles","previous_headings":"","what":"Other resources","title":"Creating a Shell Script","text":"makefile() Makefile equivalent shell_script() Data Analysis Workflows Safe, flexible workflows data analysis Episodes 1–3 Unix Shell Introduction command line Command-Line Programs Introduction Rscript","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating a Makefile","text":"Functions extract_make() makefile() help writing Makefile control data analysis workflow. extract_make() makefile() much work, extra hand coding also necessary.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"an-example-workflow","dir":"Articles","previous_headings":"","what":"An example workflow","title":"Creating a Makefile","text":"demonstrate, use simple workflow code, aside shell script, already written. project directory contains following files: src/cleaned_data.R reads raw data, cleans , creates /cleaned_data.rds src/model.R fits model cleaned data, creates /model.rds src/vals_fitted.R extract fitted values model, creates vals_fitted.rds src/fig_fitted.R uses vals_fitted.rds create plot /fig_fitted.png report.qmd uses /fig_fitted.png create document report.html cleaned_data.R, model.R, vals_fitted.R, fig_fitted.R contain calls cmd_assign(). instance, src/model.R contains lines cleaned_data.R, model.R, vals_fitted.R, fig_fitted.R contain calls cmd_assign(). instance, src/model.R contains lines","code":". ├── data │   └── raw_data.csv ├── out ├── report.qmd └── src     ├── cleaned_data.R     ├── fig_fitted.R     ├── model.R     └── vals_fitted.R cmd_assign(.cleaned_data = \"out/cleaned_data.rds\",            .out = \"out/model.rds\")"},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"extract_make","dir":"Articles","previous_headings":"","what":"extract_make()","title":"Creating a Makefile","text":"extract_make() extracts call cmd_assign() R file, turns Makefile rule. instance, call return value easiest way use extract_make() call R console, cut--paste results Makefile.","code":"extract_make(\"src/model.R\") out/model.rds: /home/runner/work/command/command/vignettes/articles/src/model.R \\   out/cleaned_data.rds     Rscript $^ $@"},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"makefile","dir":"Articles","previous_headings":"","what":"makefile()","title":"Creating a Makefile","text":"makefile() creates draft whole Makefile. makefile() loops R files directory, extracting cmd_assign() calls converting Makefile rules. puts rules Makefile. instance, call creates new file called Makefile lines output makefile() needs editing ready use. need rule creating report, make report prerequisite : top file: ordering rules Makefile reflects ordering files src directory, order rules executed. matter make, constructs dependency map. benefit human readers, rearrange rules match execution order.","code":"makefile(\"src\") .PHONY: all all:   out/cleaned_data.rds: src/cleaned_data.R \\   data/raw_data.csv     Rscript $^ $@  out/fig_fitted.png: src/fig_fitted.R \\   out/vals_fitted.rds     Rscript $^ $@  out/model.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@  out/vals_fitted.rds: src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model.rds     Rscript $^ $@   .PHONY: clean clean:     rm -rf out     mkdir out .PHONY: all all: report.html   out/cleaned_data.rds: src/cleaned_data.R \\   data/raw_data.csv     Rscript $^ $@  out/fig_fitted.png: src/fig_fitted.R \\   out/vals_fitted.rds     Rscript $^ $@  out/model.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@  out/vals_fitted.rds: src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model.rds     Rscript $^ $@  report.html: report.qmd \\   out/tab_coef.rds     quarto render $<   .PHONY: clean clean:     rm -rf out     mkdir out .PHONY: all all: report.html   out/cleaned_data.rds: src/cleaned_data.R \\   data/raw_data.csv     Rscript $^ $@  out/model.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@  out/vals_fitted.rds: src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model.rds     Rscript $^ $@  out/fig_fitted.png: src/fig_fitted.R \\   out/vals_fitted.rds     Rscript $^ $@   report.html: report.qmd \\   out/tab_coef.rds     quarto render $<   .PHONY: clean clean:     rm -rf out     mkdir out"},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"running-the-makefile","dir":"Articles","previous_headings":"","what":"Running the Makefile","title":"Creating a Makefile","text":"project directory looks like . run Makefile. project directory now looks like . created scaled.rds, model.rds, tab_coef directory, report.html main directory.","code":". ├── Makefile ├── data │   └── raw_data.csv ├── out ├── report.qmd └── src     ├── cleaned_data.R     ├── fig_fitted.R     ├── model.R     └── vals_fitted.R #make . ├── Makefile ├── data │   └── raw_data.csv ├── out ├── report.qmd └── src     ├── cleaned_data.R     ├── fig_fitted.R     ├── model.R     └── vals_fitted.R"},{"path":"https://bayesiandemography.github.io/command/articles/a3_makefile.html","id":"other-resources","dir":"Articles","previous_headings":"","what":"Other resources","title":"Creating a Makefile","text":"shell_script() shell script equivalent makefile() Data Analysis Workflows Safe, flexible workflows data analysis Project Management Make Makefiles data analysis workflows GNU make Definitive guide Command-Line Programs Introduction Rscript","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Modular Workflows for Data Analysis","text":"Code data analysis accurate, transparent, flexible. report analysis say , written way makes easy understand modify. software engineering, design systems generally, one key ways achieving accuracy, transparency, flexibility modularity (Simon 2019). modular system built many small, self-contained units. units single purpose, well-defined inputs outputs, limited knowledge units. Ideas modularity underlie much standard R advice writing code data analysis. RStudio-style projects, instance, example modular design (Wilson et al. 2017; Wickham, Çetinkaya-Rundel, Grolemund 2023; ProjectTemplate contributors 2025). However, many actual data analyses written R opposite modular. instance, entire workflow often contained single, huge script responsible everything importing data fitting creating plots. Even code analysis divided smaller scripts, smaller scripts often diffuse aims complex inputs outputs. Heavy use source() commands mean many scripts contribute objects current working environment, script can understood isolation. Changes one part workflow large, unexpected implications parts workflow. article presents strategy making data analysis workflows strictly modular. basic unit strategy script. script responsible one small task, inputs outputs tightly controlled. script runs environment, data intermediate outputs passed around reading writing disk. Information project whole held single orchestration file, serves executable description analysis. article describes main elements strategy, presents example, lists costs benefits. final section gives suggestions.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"use-lots-of-small-scripts","dir":"Articles","previous_headings":"A strategy for constructing a modular workflow","what":"Use lots of small scripts","title":"Modular Workflows for Data Analysis","text":"data analysis workflow composed many small scripts. small scripts single well-defined task. cases, task turn inputs output. new output input tasks, final product, report. either case, script self-contained, sense can interpreted used . typical inputs outputs data analyses : one-task-one-script rule can lead scripts short. instance, task merge two cleaned datasets, script might contain lines code. Occasionally, script need long, breaking task subtasks increases, rather decreases, complexity. long script , however, subjected extra checking, include comment explaining future maintainers length necessary.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"use-rscript-or-littler-to-run-each-script-in-a-new-session","dir":"Articles","previous_headings":"A strategy for constructing a modular workflow","what":"Use Rscript or littler to run each script in a new session","title":"Modular Workflows for Data Analysis","text":"script run new, clean R session ends script finished running. packages (aside base R packages) required script loaded explicitly. Running script session implies , script completes, objects created script, saved disk, disappear. best way give script session run script command line, using application Rscript littler. instance, call starts new R session, runs code -script.R, ends session. introduction Rscript see , introduction littler, see .","code":"Rscript my-script.R"},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"use-command-line-arguments-to-define-inputs-and-outputs","dir":"Articles","previous_headings":"A strategy for constructing a modular workflow","what":"Use command line arguments to define inputs and outputs","title":"Modular Workflows for Data Analysis","text":"Rscript littler allow user supply command line arguments script run. Values arguments accessible inside session. command instance, makes strings \"-data.csv\", \"myoutput.rds\", \"3\" accessible inside session -script.R run. Expressions form --<name>=<object> can used assign names strings. command , example, strings \"-data.csv\" \"myoutput.rds\" names, string \"3\" name n_digits. Values command line arguments can retrieved within session using base R function commandArgs(), followed manipulation reformatting. instance, values call can retrieved using example illustrates, using base R function commandArgs() parse command line arguments can fiddly. Packages argparse, docopt, getopt, optparse, R.utils implement high-level alternatives base R commandArgs() (Jonge, Fowler, Keleshev 2018; Davis 2023; Pav 2023; Davis Day 2020; Bengtsson 2023). command package one alternative, designed specifically data analysis workflows. Function cmd_assign() command automatically checks reformats arguments, assigns values within working environment. introduction command, see Quick Start Guide. ability pass arguments scripts essentially turns scripts functions. , instance, want run code -script.R --data.csv, rather -data.csv, use something like want process my_data.csv, want use 5 digits rather 3, use something like","code":"Rscript my-script.R my-data.csv my-output.rds --n_digits=3 args <- commandArgs(trailingOnly = TRUE) filename_input <- args[[1]] filename_output <- args[[2]] n_digits <- as.integer(strsplit(args[[3]], split = \"=\")[[1]][[2]]) Rscript my-script.R my-other-data.csv my-other-output.rds --n_digits=3 Rscript my-script.R my-data.csv my-output.rds --n_digits=5"},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"run-everything-from-an-orchestration-file","dir":"Articles","previous_headings":"A strategy for constructing a modular workflow","what":"Run everything from an orchestration file","title":"Modular Workflows for Data Analysis","text":"orchestration file controls workflow. Running orchestration file analysis reproduce entire analysis, ingesting raw data compilation final report. Orchestration files often written R, take form script runs cleaned_data.R create cleaned dataset, runs model.R fit model dataset, runs performance.R collect information model performance, renders report.qmd file create analysis report. Orchestration files consisting succession source() calls major disadvantages. Repeated use source() means code run environment, breaking modularity. lack definitions inputs outputs make workflow harder understand control. better approach use shell script, even better approach use Makefile. Makefile version shell script lines top Makefile define final output outputs workflow. Lines specify Makefile rule. rule contains target, case cleaned_data.rds; prerequisites, case cleaned_data.R raw_data.rds; recipe creating target prerequisites, case Rscript $^ $@. $^ $@ Rscript $^ $@ “automatic variables”. Makefile runs, phrase Rscript $^ $@ expands Rscript cleaned_data.R raw_data.rds cleaned_data.rds. make application uses Makefile construct dependency graph inputs outputs workflow. Makefile yields graph make sees dependency older one prerequisites, recreate dependency, dependencies downstream . instance, example , make saw performance.rds older model.rds, recreate performance.rds report.html. , however, create model.rds , cleaned_data.rds. Makefiles, see, instance, Broman (2013), Baker (2020), Janssens (2021), Turing Way Community (2025).","code":"source(\"cleaned_data.R\") source(\"model.R\") source(\"performance.R\") quarto::quarto_render(\"report.qmd\") Rscript cleaned_data.R raw_data.rds cleaned_data.rds  Rscript model.R cleaned_data.rds model.rds --n_iter=2000  Rscript performance.R model.rds performance.rds  quarto render report.qmd .PHONY: all all: report.html  cleaned_data.rds: cleaned_data.R raw_data.rds         Rscript $^ $@  model.rds: model.R cleaned_data.rds         Rscript $^ $@ --n_iter=2000  performance.rds: performance.R model.rds         Rscript $^ $@  report.html: report.qmd performance.rds         Rscript $< .PHONY: all all: report.html cleaned_data.rds: cleaned_data.R raw_data.rds         Rscript $^ $@"},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"reports","dir":"Articles","previous_headings":"A strategy for constructing a modular workflow","what":"Reports","title":"Modular Workflows for Data Analysis","text":"Applications R Markdown (Xie, Allaire, Grolemund 2018) Quarto (Posit Software, PBC 2025) allow authors combine code text within single document. common see authors put code analysis R Markdown Quarto document. can effective small analyses, exploration new dataset. scale well. Analyses code contained single R Markdown Quarto file suffer usual pathologies large, complicated code file, along extra challenge coping markdown errors. modular, scalable alternative analysis outside report, limit code within report snippets read results apply formatting. plot, instance, can constructed script, read report using command like ![](/myplot.pdf). Unfortunately, R Markdown Quarto currently allow users supply command line arguments way Rscript littler .","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"an-example","dir":"Articles","previous_headings":"","what":"An example","title":"Modular Workflows for Data Analysis","text":"use small example illustrate various components strategy described paper. project folder example looks like : Makefile report sit top level. subfolders folders raw data (data), code (src) outputs (). flow data outputs set Makefile: ultimate goal produce file report.html. get , go following steps: produce cleaned_data.rds applying cleaned_data.R raw_data.csv; produce model_m.rds applying model.R cleaned_data.rds, setting --method=M; produce model_mm.rds applying model.R cleaned_data.rds, setting --method=MM; produce vals_fitted.rds applying vals_fitted.R cleaned_data.rds, model_m.rds, model_mm.rds; produce fig_fitted.png applying fig_fitted.R vals_fitted.rds; produce report.html applying report.qmd fig_fitted.png. File cleaned_data.R contains following code: code loads packages needed script; uses function cmd_assign() package command extract values passed command line, giving names .raw_data, .; reads raw data, using filename specified .raw_data; transforms raw data cleaned data; writes cleaned data, using filename specified .. File model.R contains code overall structure similar cleaned_data.R. Unlike cleaned_data.R, however, model.R called twice. first call, named argument method set M, output captured file model_m.rds: second call, method set MM, output captured file model_mm.rds: passing arguments model.R run , can make model.R behave like function. two remaining R scripts, fig_fitted.R vals_fitted.R, follow basic format cleaned_data.R model.R, discussed Appendix. Quarto file report.qmd looks like : file focuses text rather code. single piece R code call knitr::include_graphics().","code":". ├── Makefile ├── data │   └── raw_data.csv ├── out │   ├── cleaned_data.rds │   ├── fig_fitted.png │   ├── model_m.rds │   ├── model_mm.rds │   └── vals_fitted.rds ├── report.html ├── report.qmd └── src     ├── cleaned_data.R     ├── fig_fitted.R     ├── model.R     └── vals_fitted.R .PHONY: all all: report.html  out/cleaned_data.rds: src/cleaned_data.R \\   data/raw_data.csv     Rscript $^ $@  out/model_m.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@ --method=M  out/model_mm.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@ --method=MM  out/vals_fitted.rds: src/vals_fitted.R \\   out/cleaned_data.rds \\   out/model_m.rds \\   out/model_mm.rds     Rscript $^ $@  out/fig_fitted.png: src/fig_fitted.R \\   out/vals_fitted.rds     Rscript $^ $@  report.html: report.qmd \\   out/fig_fitted.png     quarto render report.qmd   .PHONY: clean clean:     rm -rf out     mkdir out suppressPackageStartupMessages({   library(readr)   library(dplyr)   library(command) })  cmd_assign(.raw_data = \"data/raw_data.csv\",            .out = \"out/cleaned_data.rds\")  raw_data <- read_csv(.raw_data, show_col_types = FALSE)  cleaned_data <- raw_data |>   mutate(agriculture = scale(Agriculture),          fertility = scale(Fertility),          agriculture = as.numeric(agriculture),          fertility = as.numeric(fertility)) |>   select(province = Province, agriculture, fertility)  saveRDS(cleaned_data, file = .out) suppressPackageStartupMessages({   library(MASS)   library(command) })  cmd_assign(.cleaned_data = \"out/cleaned_data.rds\",            method = \"M\",            .out = \"out/model.rds\")  cleaned_data <- readRDS(.cleaned_data)  model <- rlm(fertility ~ agriculture,               data = cleaned_data,              method = \"M\")  saveRDS(model, file = .out) out/model_m.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@ --method=M out/model_mm.rds: src/model.R \\   out/cleaned_data.rds     Rscript $^ $@ --method=MM --- title: \"Swiss Fertility\" ---  ## Introduction  We examine the relationship between agriculture and fertility in nineteenth century Swizterland.  ## Methods  We fit a robust linear model to provincial-level data, using methods \"M\" and \"MM\".  ## Results  Here are the raw data and the fitted values:  ```{r} #| echo: false #| out.width: 60% knitr::include_graphics(\"out/fig_fitted.png\") ```  ## Discussion  Fertility was positively correlated with agriculture."},{"path":[]},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"learning-new-tools","dir":"Articles","previous_headings":"Costs of the strategy","what":"Learning new tools","title":"Modular Workflows for Data Analysis","text":"Analysts familiar command line, shell scripts, Makefiles need devote time learning . Makefiles, particular, can take time get used , mysterious $^ $@ symbols tricky use tabs. Learning tools, finding solutions something goes wrong, , however, become much easier advent AI-based assistants.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"extra-overhead","dir":"Articles","previous_headings":"Costs of the strategy","what":"Extra overhead","title":"Modular Workflows for Data Analysis","text":"strategy described paper requires writing extra code. Every script analysis requires extra lines deal command line arguments, needs mention orchestration file.","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"writing-code","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Writing code","title":"Modular Workflows for Data Analysis","text":"Modularity makes code easier write. Breaking analysis smaller pieces makes feel manageable. small script one job much places fewer demands programmer’s memory concentration large script many jobs. self-contained script , fewer assumptions makes rest project, less likely need revision project evolves. Modularity also helps one difficult tasks programming: naming things (McConnell 2004, chap. 11). challenge finding appropriate names, avoiding name clashes, particularly acute long file carrying multiple tasks, becomes necessary distinguish, instance, model_baseline, model_revised, model_revised_subset, . short scripts, run session, allows analysts re-use clashes, need search distinct names.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"reading-code","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Reading code","title":"Modular Workflows for Data Analysis","text":"Code takes form small, self-contained units also much easier read. small script single objective makes can understood much quickly large script several objectives. Code constructed semi-independent units can picked part way , sparing reader need read code just understand one part . separate orchestration file allows reader see overall structure analysis, including main steps, flow information.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"documentation","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Documentation","title":"Modular Workflows for Data Analysis","text":"Computer code ideally ‘self-documenting’: make programmer’s intent sufficiently clear need additional aids, inline comments README files, minimized (McConnell 2004, chap. 32). Many techniques described paper lead code self-documenting. orchestration file, instance, serves summary overall workflow, command line arguments serve description inputs outputs. addition, script short single objective, reader needs much less assistance script long multiple objectives.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"debugging","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Debugging","title":"Modular Workflows for Data Analysis","text":"Keeping scripts short, running script session, explicitly defining inputs session mean , something goes wrong, objects working environment, origins objects clear. Debugging lot less painful might otherwise .","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"flexibility","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Flexibility","title":"Modular Workflows for Data Analysis","text":"Small scripts, clearly-defined inputs, outputs, tasks composable: can combined scripts many different ways. Consider, instance, problem extracting performance measures model object plotting . one script derive performance measures, second script plot measures, easy add third script display measures table. sort flexibility particularly helpful data analyses uncertainty nature data appropriate models, plots, forth.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"scalability","dir":"Articles","previous_headings":"Benefits of the strategy","what":"Scalability","title":"Modular Workflows for Data Analysis","text":"Saving intermediate outputs disk reduces amount memory needed, reduces need re-run calculations beginning. savings can important projects large datasets long computation times. Makefiles particularly helpful settings, since make sure computations carried needed, .","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"let-the-orchestration-file-impose-order","dir":"Articles","previous_headings":"Some stylistic suggestions","what":"Let the orchestration file impose order","title":"Modular Workflows for Data Analysis","text":"common recommendation advice writing analysis code number files, 01-ingest-data.R, 02-clean-data.R, 03-fit-model.R, . problem recommendation data analysis unpredictable, new files often need added, existing files deleted. , instance, insert impute-missing-values step clean-data step fit-model step, need redo numbering. quickly becomes annoying. alternative rely entirely orchestration file record order files run. analyst needs update orchestration file anyway, time script added removed. orchestration file, numbering becomes redundant. One quirk case Makefiles , building dependency graph, make application relies entirely targets prerequisites, ignores physical position rules within file. courtesy human readers, however, Makefile list rules order executed.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"re-use-base-names","dir":"Articles","previous_headings":"Some stylistic suggestions","what":"Re-use base names","title":"Modular Workflows for Data Analysis","text":"computer science convention related files given base name different extensions – e.g. report.tex, report.aux, report.toc, report.log, report.pdf – can also applied data analysis workflows. instance, file named model_baseline.R creates model object, stored file named model_baseline.rds. well signaling relationships, re-using base names reduces need think new names.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"objects-holding-file-paths-start-with-a-dot","dir":"Articles","previous_headings":"Some stylistic suggestions","what":"Objects holding file paths start with a dot","title":"Modular Workflows for Data Analysis","text":"Often, running script, read object file, using file path supplied command line. instance, read object file called model.rds, identify using path /model.rds, supplied command line. cases, need names () object read , (ii) path file object stored. useful convention give (ii) name (), dot front. instance, give object read name model, give object holding path name .model. Following convention leads code distinction object path object analogous distinction value reference value. dot-name convention makes connection value reference clear, also alerts reader fact objects holding file paths little unusual.","code":"cmd_assign(.data = \"out/model.rds\",            .out = \"out/vals_fitted.rds\")  model <- readRDS(.model)"},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"refrain-from-using-advanced-makefile-features","dir":"Articles","previous_headings":"Some stylistic suggestions","what":"Refrain from using advanced Makefile features","title":"Modular Workflows for Data Analysis","text":"Makefiles enormous range features. extra power tends, however, come expense readability. Moreover, data analysis projects sufficiently simple structure extra power really needed. ‘VPATH directives’ added Makefile, instance, directory names can omitted file paths, model.R can used instead src/model.R (Free Software Foundation 2024, sec. 4.5). Omitting directory names makes Makefiles concise, also makes harder understand readers Makefile experts.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"orchestration-and-report-files-at-the-top","dir":"Articles","previous_headings":"Some stylistic suggestions","what":"Orchestration and report files at the top","title":"Modular Workflows for Data Analysis","text":"orchestration file, report files LaTeX, R Markdown, Quarto, similar, sit top level project, rather subfolder code. , instance, way project Example section structured. pragmatic reasons placing orchestration report files top level: Makefiles, LaTeX files, markdown files generally assume top level, require special handling . orchestration report files also earn special treatment, special status within project. Orchestration files control files, report typically ultimate objective project.","code":""},{"path":"https://bayesiandemography.github.io/command/articles/a4_workflow.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"Modular Workflows for Data Analysis","text":"File vals_fitted.R example contains following code: code loads packages used code; creates strings called .cleaned_data, .model_m, .model_mm, ., based values passed command line; creates objects cleaned_data, model_m, model_mm, reading files specified .cleaned_data, .model_m, .model_mm; combines reformats contents cleaned_data, model_m, model_mm; writes result, file specified .. File fig_fitted.R contains code code loads packages used code; creates strings called .vals_fitted ., based values passed command line; creates object vals_fitted, reading file specified `.vals_fitted; creates plot, based vals_fitted; prints plot file specified ..","code":"suppressPackageStartupMessages({   library(dplyr)   library(tidyr)   library(command) })  cmd_assign(.cleaned_data = \"out/cleaned_data.rds\",            .model_m = \"out/model_m.rds\",            .model_mm = \"out/model_mm.rds\",            .out = \"out/vals_fitted.rds\")  cleaned_data <- readRDS(.cleaned_data) model_m <- readRDS(.model_m) model_mm <- readRDS(.model_mm)  vals_fitted <- cleaned_data |>   mutate(m = fitted(model_m),          mm = fitted(model_mm)) |>   pivot_longer(c(m, mm),                names_to = \"variant\",                values_to = \"fitted\")             saveRDS(vals_fitted, file = .out) suppressPackageStartupMessages({   library(ggplot2)   library(command) })  cmd_assign(.vals_fitted = \"out/vals_fitted.rds\",            .out = \"out/fig_fitted.png\")  vals_fitted <- readRDS(.vals_fitted)  p <- ggplot(vals_fitted, aes(x = agriculture)) +   facet_wrap(vars(variant)) +   geom_point(aes(y = fertility)) +   geom_line(aes(y = fitted))                 png(file = .out,     width = 600,     height = 300) plot(p) dev.off()"},{"path":[]},{"path":"https://bayesiandemography.github.io/command/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"John Bryant. Author, maintainer. Bayesian Demography Limited. Copyright holder.","code":""},{"path":"https://bayesiandemography.github.io/command/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bryant J (2025). command: Process Command Line Arguments. R package version 0.1.1, https://bayesiandemography.github.io/command/.","code":"@Manual{,   title = {command: Process Command Line Arguments},   author = {John Bryant},   year = {2025},   note = {R package version 0.1.1},   url = {https://bayesiandemography.github.io/command/}, }"},{"path":"https://bayesiandemography.github.io/command/index.html","id":"command","dir":"","previous_headings":"","what":"Process Command Line Arguments","title":"Process Command Line Arguments","text":"Process command line arguments part data analysis workflow. cmd_assign() main function Quick Start Guide use cmd_assign(). Modular Workflows Data Analysis Safe, flexible data analysis projects","code":""},{"path":"https://bayesiandemography.github.io/command/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Process Command Line Arguments","text":"","code":"install.packages(\"command\")"},{"path":"https://bayesiandemography.github.io/command/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Process Command Line Arguments","text":"","code":"cmd_assign(.data = \"data/raw_data.csv\",            date_start = \"2025-01-01\",            trim_outliers = TRUE,            .out = \"out/cleaned_data.rds\")"},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign Values Passed at the Command Line or Interactively — cmd_assign","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"Assign values names working environment. values typically supplied command line, can supplied interactively. Specifying inputs outputs scripts command line can contribute safter, modular workflows.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"","code":"cmd_assign(...)"},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"... Name-value pairs.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"cmd_assign() called side effect, create objects global environment. However, cmd_assign() also invisibly returns named list objects.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"types-of-session","dir":"Reference","previous_headings":"","what":"Types of session","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"cmd_assign() behaves differently depending whether called interactively, inside R script run command line. instance, code cmd_assign(use_log = TRUE) run interactively, creates object called use_log value TRUE. code run inside script via command Rscript tidy_data.R --use_log=FALSE creates object called use_log value FALSE. cmd_assign() typically called interactively workflow developed, command line workflow matured.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"matching-names-and-values","dir":"Reference","previous_headings":"","what":"Matching names and values","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"used script called command line, cmd_assign() first matches named command line arguments, matches unnamed command line arguments, order supplied. , instance, script person.R contains lines   person.R run command line using   cmd_assign() first matches named command line argument --max_age=100 cmd_assign() argument max_age, matches unnamed command line arguments raw_data.csvandperson.rdstocmd_assign()arugments.dataand.`.","code":"cmd_assign(.data = \"raw_data.csv\",            max_age = 85,            .out = \"person.rds\") Rscript person.R raw_data.csv person.rds --max_age=100"},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"coercing-values-passed-at-the-command-line","dir":"Reference","previous_headings":"","what":"Coercing values passed at the command line","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"Values passed command line start text strings. cmd_assign() coerces text strings class corresponding values call cmd_assign(). instance, script called fit.R contains lines   fitted.R run command line using   cmd_assign() create character vector called .data value \"cleaned.rds\", logical vector called impute value TRUE, date vector called date value \"2025-01-01\", character vector called .value `\"fit.rds\".","code":"cmd_assign(.data = \"cleaned.rds\",            impute = TRUE,            date = as.Date(\"2026-01-01\"),            .out = \"fit.rds\") Rscript fitted.R cleaned.rds fit.rds --impute=TRUE --date=2025-01-01"},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"Command-Line Programs Introduction Rscript","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/cmd_assign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign Values Passed at the Command Line or Interactively — cmd_assign","text":"","code":"if (interactive()) {   cmd_assign(.data = \"mydata.csv\",              n_iter = 2000,              .out = \"results.rds\") }"},{"path":"https://bayesiandemography.github.io/command/reference/command-package.html","id":null,"dir":"Reference","previous_headings":"","what":"command: Process command line arguments — command-package","title":"command: Process command line arguments — command-package","text":"Process arguments passed command line, part data analysis workflow.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/command-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"command: Process command line arguments — command-package","text":"cmd_assign() Process command line arguments extract_shell() Turn cmd_assign() call shell command extract_make() Turn cmd_assign() call Makefile rule shell_script() Create shell script makefile() Create Makefile Quick Start Guide use cmd_assign() Modular Workflows Data Analysis Safe, flexible data analysis workflows","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/command-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"command: Process command line arguments — command-package","text":"Maintainer: John Bryant john@bayesiandemography.com contributors: Bayesian Demography Limited [copyright holder]","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"Extract call cmd_assign() R script, turn Makefile rule.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"","code":"extract_make(path_file, dir_make = NULL)"},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"path_file path dir_make R scripe containing call cmd_assign(). dir_make directory contains Makefile. default current working directory.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"extract_make() typically called side effect, print Makefile rule. However, extract_make() invisibly returns text string rule.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"the-components-of-a-makefile-rule","dir":"Reference","previous_headings":"","what":"The components of a Makefile rule","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"Makefile rule produced extract_make() normally looks something like :   rule /model.rds \"target\", .e. file rule creates; src/model.R data/timeseries.rds \"prerequisites\", .e. files used create target; \\ \"line continuation character\"; start third line tab, telling make recipe creating target starts ; Rscript call utils::Rscript(); $^ automatic variable meaning \"prerequisites\" $@ automatic variable meaning \"target\", Rscript $^ $@ expands Rscript src/model.R data/cleaned.rds /model.rds; --use_log=TRUE named argument Rscript passes src/model.R","code":"out/model.rds: src/model.R \\   data/cleaned.rds        Rscript $^ $@ --use_log=TRUE"},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"using-extract-make-to-build-a-data-analysis-workflow","dir":"Reference","previous_headings":"","what":"Using extract_make() to build a data analysis workflow","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"Step 1. Write R file carries step analysis (eg tidying data, fitting model, making graph.) file contain call cmd_assign(),  appear first line Makefile rule. writing testing file, use cmd_assign() interactively. Step 2. R file working correctly, call extract_make(), add rule Makefile. using extract_make(), good idea set current working directory project directory (something happen automatically using RStudio projects.)","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"location-of-the-makefile","dir":"Reference","previous_headings":"","what":"Location of the Makefile","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"Makefile normally sets top project, project folder looks something like :","code":"Makefile - data/ - src/ - out/ report.qmd"},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"identifying-file-arguments","dir":"Reference","previous_headings":"","what":"Identifying file arguments","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"construct Makefile rule, extract_make() needs able pick arguments refer file names. , uses following heuristic: call includes arguments whose names start dot, arguments assumed refer file names; otherwise, find arguments whose values actually file names (determined file.exists()), look like .","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"Project Management Make Makefiles data analysis workflows GNU make Definitive guide Command-Line Programs Introduction Rscript","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/extract_make.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn a 'cmd_assign' Call Into a Makefile Rule — extract_make","text":"","code":"library(fs)  ## Create project directory containing ## 'src' and 'out' directories path_project <- file_temp() dir_create(path_project) dir_create(path(path_project, \"src\")) dir_create(path(path_project, \"out\"))  ## Put R script in 'src' directory writeLines(c(\"cmd_assign(x = 1, .out = 'out/results.rds')\",              \"results <- x + 1\",              \"saveRDS(results, file = .out)\"),            con = path(path_project, \"src/results.R\"))  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d2c067447 #> ├── out #> └── src #>     └── results.R  ## Look at contents of R script lines <- readLines(path(path_project, \"src/results.R\")) cat(paste(lines, collapse = \"\\n\")) #> cmd_assign(x = 1, .out = 'out/results.rds') #> results <- x + 1 #> saveRDS(results, file = .out)  ## call 'extract_make()' extract_make(path_file = \"src/results.R\",          dir_make = path_project) #> out/results.rds: /tmp/RtmpPmhqwm/file1e9d2c067447/src/results.R #> \tRscript $^ $@ --x=1  ## clean up dir_delete(path_project)"},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"Extract call cmd_assign() R script, turn shell command.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"","code":"extract_shell(path_file, dir_shell = NULL)"},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"path_file Path R script containing call cmd_assign(). path starts dir_shell. dir_shell directory contains shell script. default current working directory.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"extract_shell() typically called side effect, print shell command. However, extract_shell() invisibly returns text string command.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"the-components-of-a-shell-command","dir":"Reference","previous_headings":"","what":"The components of a shell command","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"shell command produced extract_shell() normally looks something like :   command Rscript call utils::Rscript(); \\ \"line continuation character\"; data/cleaned.rds /model.rds unnamed arguments Rscript passes src/model.R; --use_log=TRUE named argument Rscript passes src/model.R","code":"Rscript src/model.R \\   data/cleaned.rds \\   out/model.rds \\   --use_log=TRUE"},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"using-extract-shell-to-build-a-data-analysis-workflow","dir":"Reference","previous_headings":"","what":"Using extract_shell() to build a data analysis workflow","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"Step 1. Write R script carries step analysis (eg tidying data, fitting model, making graph.) script contain call cmd_assign(),  first argument passed Rscript shell command. writing testing script, use cmd_assign() interactively. Step 2. R script working correctly, call extract_shell(), add command shell script.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"location-of-the-shell-script","dir":"Reference","previous_headings":"","what":"Location of the shell script","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"shell script normally sits top level project, project folder looks something like :","code":"workflow.sh - data/ - src/ - out/ report.qmd"},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"identifying-file-arguments","dir":"Reference","previous_headings":"","what":"Identifying file arguments","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"construct rule, extract_shell() needs able identify arguments refer file name. , uses following heuristic: call includes arguments whose names start dot, arguments assumed refer file names; otherwise, find arguments whose values actually file names (determined file.exists()) look like .","code":""},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"Episodes 1–3 Unix Shell Introduction command line Command-Line Programs Introduction Rscript littler Alternative Rscript","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/extract_shell.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn a 'cmd_assign' Call Into a Shell Command — extract_shell","text":"","code":"library(fs)  ## Create project directory containing ## 'src' and 'out' directories path_project <- file_temp() dir_create(path_project) dir_create(path(path_project, \"src\")) dir_create(path(path_project, \"out\"))  ## Put R script in 'src' directory writeLines(c(\"cmd_assign(x = 1, .out = 'out/results.rds')\",              \"results <- x + 1\",              \"saveRDS(results, file = .out)\"),            con = path(path_project, \"src/results.R\"))  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d7bae2553 #> ├── out #> └── src #>     └── results.R  ## Look at contents of R script lines <- readLines(path(path_project, \"src/results.R\")) cat(paste(lines, collapse = \"\\n\")) #> cmd_assign(x = 1, .out = 'out/results.rds') #> results <- x + 1 #> saveRDS(results, file = .out)  ## call 'extract_shell()' extract_shell(path_file = \"src/results.R\",           dir_shell = path_project) #> Rscript /tmp/RtmpPmhqwm/file1e9d7bae2553/src/results.R \\ #>   out/results.rds \\ #>   --x=1  ## clean up dir_delete(path_project)"},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Makefile — makefile","title":"Create a Makefile — makefile","text":"Create Makefile data analysis workflow. Makefile can include rules extracted existing R files.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Makefile — makefile","text":"","code":"makefile(   path_files = NULL,   dir_make = NULL,   name_make = \"Makefile\",   overwrite = FALSE )"},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Makefile — makefile","text":"path_files path dir_make directory R scripts containing calls cmd_assign(). Optional. dir_make directory makefile() create Makefile. value supplied, `makefile(); creates Makefile current working directory. name_make name Makefile. default \"Makefile\". overwrite Whether overwrite existing Makefile. Default FALSE.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Makefile — makefile","text":"makefile() called side effect, create file. However, makefile() also returns string contents Makefile.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Makefile — makefile","text":"create Makefile files directory, set files \".\". obtain contents Makefile without creating file disk, creating file disk, set name_make NULL. Supplying value files optional makefile(), compulsory shell_script(). output makefile() includes general-purpose Makefile commands, output shell_script() generated entirely files.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Makefile — makefile","text":"Project Management Make Makefiles data analysis workflows GNU make Definitive guide Command-Line Programs Introduction Rscript","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/makefile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Makefile — makefile","text":"","code":"library(fs)  ## Create project directory containing ## 'src' and 'out' directories path_project <- file_temp() dir_create(path_project) dir_create(path(path_project, \"src\")) dir_create(path(path_project, \"out\"))  ## Put R code file in 'src' directory writeLines(c(\"cmd_assign(x = 1, .out = 'out/results.rds')\",              \"results <- x + 1\",              \"saveRDS(results, file = .out)\"),            con = path(path_project, \"src/results.R\"))  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d6f0ea706 #> ├── out #> └── src #>     └── results.R  ## Call 'makefile()' makefile(path_files = \"src\",          dir_make = path_project) #> ✔ Extracted call to `cmd_assign()` in src/results.R.  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d6f0ea706 #> ├── Makefile #> ├── out #> └── src #>     └── results.R  ## Look at contents of makefile lines <- readLines(path(path_project, \"Makefile\")) cat(paste(lines, collapse = \"\\n\")) #>  #> .PHONY: all #> all: #>  #>  #> out/results.rds: src/results.R #> \tRscript $^ $@ --x=1 #>  #>  #> .PHONY: clean #> clean: #> \trm -rf out #> \tmkdir out #>   ## Get the text of the Makefile ## without creating a file on disk text <- makefile(path_files = \"src\",                  dir_make = path_project,                  name_make = NULL) #> ✔ Extracted call to `cmd_assign()` in src/results.R. cat(text) #>  #> .PHONY: all #> all: #>  #>  #> out/results.rds: src/results.R #> \tRscript $^ $@ --x=1 #>  #>  #> .PHONY: clean #> clean: #> \trm -rf out #> \tmkdir out #>   ## Clean up dir_delete(path_project)"},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Shell Script — shell_script","title":"Create a Shell Script — shell_script","text":"Create shell script data analysis workflow consisting commands extracted existing R files.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Shell Script — shell_script","text":"","code":"shell_script(   path_files,   dir_shell = NULL,   name_shell = \"workflow.sh\",   overwrite = FALSE )"},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Shell Script — shell_script","text":"path_files path dir_shell directory R scripts containing calls cmd_assign(). dir_shell directory shell_script() create shell script. value supplied, shell_script() creates shell script current working directory. name_shell name shell script. default \"workflow.sh\". overwrite Whether overwrite existing shell script. Default FALSE.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Shell Script — shell_script","text":"shell_script() called side effect, create file. However, shell_script() also returns string contents shell script.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Shell Script — shell_script","text":"create shell script files directory, set files \".\". obtain contents shell script without creating file disk, creating file disk, set name_shell NULL. Supplying value files compulsory shell_script(), optional makefile(). output shell_script() generated entirely files output makefile() also includes general-purpose Makefile commands.","code":""},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a Shell Script — shell_script","text":"Episodes 1–3 Unix Shell Introduction command line Command-Line Programs Introduction Rscript","code":""},{"path":[]},{"path":"https://bayesiandemography.github.io/command/reference/shell_script.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Shell Script — shell_script","text":"","code":"library(fs)  ## Create project directory containing ## 'src' and 'out' directories path_project <- file_temp() dir_create(path_project) dir_create(path(path_project, \"src\")) dir_create(path(path_project, \"out\"))  ## Put R code file in 'src' directory writeLines(c(\"cmd_assign(x = 1, .out = 'out/results.rds')\",              \"results <- x + 1\",              \"saveRDS(results, file = .out)\"),            con = path(path_project, \"src/results.R\"))  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d7994f835 #> ├── out #> └── src #>     └── results.R  ## Call 'shell_script()' shell_script(path_files = \"src\",              dir_shell = path_project) #> ✔ Extracted call to `cmd_assign()` in src/results.R.  ## Look at directories dir_tree(path_project) #> /tmp/RtmpPmhqwm/file1e9d7994f835 #> ├── out #> ├── src #> │   └── results.R #> └── workflow.sh  ## Look at contents of shell script lines <- readLines(path(path_project, \"workflow.sh\")) cat(paste(lines, collapse = \"\\n\")) #>  #> Rscript src/results.R \\ #>   out/results.rds \\ #>   --x=1 #>   ## Get the text of the shell script ## without creating a file on disk text <- shell_script(path_files = \"src\",                      dir_shell = path_project,                      name_shell = NULL) #> ✔ Extracted call to `cmd_assign()` in src/results.R. cat(text) #>  #> Rscript src/results.R \\ #>   out/results.rds \\ #>   --x=1 #>   ## Clean up dir_delete(path_project)"},{"path":"https://bayesiandemography.github.io/command/news/index.html","id":"command-010","dir":"Changelog","previous_headings":"","what":"command 0.1.0","title":"command 0.1.0","text":"Initial CRAN submission.","code":""}]
